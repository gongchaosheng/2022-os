# Rust_Rustlings_String
## 字符串类型`String`和`&str`
`Rust`字符串，往往指的就是`String`类型和`&str`字符串切片类型，这两个类型都是`UTF-8`编码。前者可变后者不可变。  

就字符串字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件中，这使得字符串字面值快速且高效，这主要得益于字符串字面值的不可变性。
但是我们不能为了获得这种性能，而把每一个在编译时大小未知的文本都放进内存中（你也做不到！），因为有的字符串是在程序运行得过程中动态生成的。  

对于 String 类型，为了支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，这些都是在程序运行时完成的：
+ 首先向操作系统请求内存来存放 String 对象
+ 在使用完成后，将内存释放，归还给操作系统
## `String`和`&str`的转化
+ `&Str`转化为`String`:  
```
let s1 = "hello";
let mut s2 = String::from(s1);
let s3 = String::from("hello");
let s4 = s1.to_string();
```
`s2`可变，`s3`和`s4`不可变。
+ `String`转化为`&str`:  
```
let s1 = "hello";
let s2 = String::from(s1);
let s3 = s2[0..2];
let s4 = &s2;
```
`s3`和`s4`都是&str。
## 字符串索引和切片
`Rust`不允许使用索引访问字符串。
```
fn main() {
   let s1 = String::from("hello");
   let h = s1[0];
}
```
这是因为在`Rust`中，字符串底层是一个`u8`字节数组，按字节来划分。
```
fn main() {
let hello = String::from("中国人");
let s = hello[0];
}
```
但是一个中文字符占据`3`个字节，当使用`hello[0]来访问时，我们只访问了`中`三个字节中的第一个字节，因此`Rust`不允许这种行为。
同理，当我们使用切片的时候也要切片索引注意字符字节的划分。
## 操作字符串
### 替换(replace)
`let new_s = s.replace("rust","Rust");`replace`返回一个新的字符串。
### 连接(concatenate)
使用`+`或者`+=`连接字符串，要求右边的参数必须为字符串的切片引用`Slice`类型。
`let new_s = string_1 + &string_2`
`+`或者`+=`都是返回一个新的字符串。
### 追加(push)
`push`直接修改原有的字符串，因此要求字符串是可变`mut`的。
``` s.puth("abcd")```
### 插入(insert)
`insert`也是直接修改原有字符串，因此要求字符串是可变`mut`的。
```
fn main() {
    let mut s = String::from("Hello rust!");
    s.insert(5, ',');
    println!("插入字符 insert() -> {}", s);
    s.insert_str(6, " I like");
    println!("插入字符串 insert_str() -> {}", s);
}
```
### 删除(delete)
`pop`删除原字符串最后一个字符并返回
```
let mut s = String::from("Hello rust!");
let poped = s.pop() ;
```
`poped`的值为`!`  

`remove`是删除原字符串第`i`个字符,返回值为剩余的字符串
```
let mut s = String::from("Hello rust!");
let poped = s.remove(0);
```
`poped`的值为`ello rust!`  
## 常见的`String`和`&str`类型区分


